<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sniper Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #crosshairs {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            /* Hidden by default, shown when zoomed via JavaScript */
            pointer-events: none;
            /* Ensures it doesn’t interfere with mouse events */
        }

        #crosshairs .circle {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 10px solid grey;
            /* Thick grey border for the telescopic sight */
            border-radius: 50%;
            /* Makes it a circle */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Centers it within #crosshairs */
        }

        #crosshairs .vertical {
            position: absolute;
            width: 2px;
            height: 200px;
            /* Matches the circle’s diameter */
            background: black;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Centers it */
        }

        #crosshairs .horizontal {
            position: absolute;
            width: 200px;
            /* Matches the circle’s diameter */
            height: 2px;
            background: black;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Centers it */
        }

        #winDialog {
            display: none;
            /* Hidden initially */
            position: fixed;
            /* Stays in place over the canvas */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            /* Centers the dialog */
            background: white;
            padding: 20px;
            border: 1px solid black;
            z-index: 1000;
            /* Ensures it’s above the Three.js canvas */
            text-align: center;
        }

        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #splashScreen button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>

<body>

    <div id="crosshairs">
        <div class="circle"></div>
        <div class="vertical"></div>
        <div class="horizontal"></div>
    </div>
    <div id="winDialog">
        <h1>You Won!</h1>
        <button id="restartButton">Restart Game</button>
    </div>
    <div id="splashScreen">
        <h1>Sniper Game</h1>
        <h2>Controls</h2>
        <p><strong>Shift:</strong> Zoom In</p>
        <p><strong>Move Mouse:</strong> Aim</p>
        <p><strong>Mouse Click:</strong> Fire Weapon</p>
        <button id="startButton">Start Game</button>
    </div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 0, 100); // Light blue fog for depth

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 20); // Player height at ~1.7m, positioned away from fence

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87ceeb); // Sky-like background
        document.body.appendChild(renderer.domElement);

        // Pointer lock controls for first-person aiming
        const controls = new PointerLockControls(camera, renderer.domElement);

        // Lighting
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Ground (lush green grass)
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshToonMaterial({ color: 0x00ff00 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Horizontal
        scene.add(ground);

        // Rolling hills
        const hillGeometry = new THREE.SphereGeometry(10, 32, 32);
        const hillMaterial = new THREE.MeshToonMaterial({ color: 0x00ff00 });
        const hill1 = new THREE.Mesh(hillGeometry, hillMaterial);
        hill1.position.set(20, 5, -30);
        hill1.scale.set(1, 0.5, 1); // Flatten to resemble hills
        scene.add(hill1);

        const hill2 = new THREE.Mesh(hillGeometry, hillMaterial);
        hill2.position.set(-20, 5, -40);
        hill2.scale.set(1, 0.5, 1);
        scene.add(hill2);

        // Fence posts
        const postGeometry = new THREE.BoxGeometry(0.5, 5, 0.5);
        const postMaterial = new THREE.MeshToonMaterial({ color: 0x8B4513 }); // Brown wood
        const post1 = new THREE.Mesh(postGeometry, postMaterial);
        post1.position.set(0, 2.5, -10);
        scene.add(post1);

        const post2 = new THREE.Mesh(postGeometry, postMaterial);
        post2.position.set(5, 2.5, -10);
        scene.add(post2);

        const post3 = new THREE.Mesh(postGeometry, postMaterial);
        post3.position.set(10, 2.5, -10);
        scene.add(post3);

        // Fence rails
        const railGeometry = new THREE.BoxGeometry(5, 0.2, 0.2);
        const railMaterial = new THREE.MeshToonMaterial({ color: 0x8B4513 });
        const rail1 = new THREE.Mesh(railGeometry, railMaterial);
        rail1.position.set(2.5, 4, -10);
        scene.add(rail1);

        const rail2 = new THREE.Mesh(railGeometry, railMaterial);
        rail2.position.set(7.5, 4, -10);
        scene.add(rail2);

        const rail3 = new THREE.Mesh(railGeometry, railMaterial);
        rail3.position.set(2.5, 2, -10);
        scene.add(rail3);

        const rail4 = new THREE.Mesh(railGeometry, railMaterial);
        rail4.position.set(7.5, 2, -10);
        scene.add(rail4);

        // Bottles
        const bottleMaterial = new THREE.MeshToonMaterial({ color: 0x00ffff }); // Cyan bottles
        function createBottle(x, z) {
            const bottleGroup = new THREE.Group();
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 32);
            const body = new THREE.Mesh(bodyGeometry, bottleMaterial);
            body.position.set(0, 1, 0); // Bottom at y=0, top at y=2 in group coords
            const neckGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
            const neck = new THREE.Mesh(neckGeometry, bottleMaterial);
            neck.position.set(0, 2.25, 0); // From y=2 to y=2.5
            bottleGroup.add(body);
            bottleGroup.add(neck);
            bottleGroup.position.set(x, 5, z); // Bottom at y=5 (on fence)
            return bottleGroup;
        }

        // Define initial bottle positions
        const bottlePositions = [
            { x: 0, z: -10 },
            { x: 5, z: -10 },
            { x: 10, z: -10 }
        ];

        // Global bottles array
        let bottles = [];

        // Function to initialize or reset bottles
        function initBottles() {
            // Remove any existing bottles from the scene
            bottles.forEach(bottle => scene.remove(bottle));
            bottles = []; // Clear the array
            // Create new bottles at initial positions
            bottlePositions.forEach(pos => {
                const bottle = createBottle(pos.x, pos.z);
                scene.add(bottle);
                bottles.push(bottle);
            });
        }

        // Zoom functionality
        let isZoomed = false;
        const crosshairs = document.getElementById('crosshairs');
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') isZoomed = true;
        });
        document.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') isZoomed = false;
        });

        const clouds = [];
        for (let i = 0; i < 5; i++) {
            const cloud = createCloud(
                Math.random() * 50 - 25, // x: -25 to 25
                20 + Math.random() * 10, // y: 20 to 30
                -30 + Math.random() * 20 // z: -30 to -10
            );
            scene.add(cloud);
            clouds.push(cloud);
        }

        function createCloud(x, y, z) {
            // Create a group to hold the cloud parts
            const cloudGroup = new THREE.Group();

            // Use a whiter material
            const cloudMaterial = new THREE.MeshToonMaterial({ color: 0xFFFFFF });

            // Add more spheres for fluffiness
            for (let i = -2; i <= 2; i++) {
                for (let j = -2; j <= 2; j++) {
                    const sphere = new THREE.Mesh(
                        new THREE.SphereGeometry(1.5, 16, 16), // Larger spheres (radius 1.5)
                        cloudMaterial
                    );
                    // Randomize positions for a fluffier look
                    sphere.position.set(
                        i * 2 + (Math.random() - 0.5),
                        j * 2 + (Math.random() - 0.5),
                        (Math.random() - 0.5)
                    );
                    cloudGroup.add(sphere);
                }
            }

            // Position the cloud in the scene
            cloudGroup.position.set(x, y, z);

            // Scale the entire cloud to make it bigger
            cloudGroup.scale.set(1.5, 1.5, 1.5);

            return cloudGroup;
        }

        // Shooting mechanism
        renderer.domElement.addEventListener('click', () => {
            if (controls.isLocked) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(bottles, true);
                if (intersects.length > 0) {
                    const hitObject = intersects[0].object;
                    const hitBottle = hitObject.parent;
                    if (bottles.includes(hitBottle)) {
                        const position = hitBottle.position.clone();
                        scene.remove(hitBottle);
                        bottles.splice(bottles.indexOf(hitBottle), 1);
                        const shardGroup = createShards(position.x, position.y, position.z);
                        shardGroup.lifespan = 60; // Remove after 60 frames
                        scene.add(shardGroup);
                        shards.push(shardGroup);
                        if (bottles.length === 0) {
                            setTimeout(() => {
                                isZoomed = false; // Zoom out to normal level
                                document.getElementById('winDialog').style.display = 'block';
                                controls.unlock(); // Release pointer lock for button interaction
                            }, 1500); // Wait for 1.5 seconds
                        }
                    }
                }
            }
        });

        document.getElementById('restartButton').addEventListener('click', () => {
            initBottles(); // Recreate bottles
            document.getElementById('winDialog').style.display = 'none'; // Hide dialog
            controls.lock(); // Lock the controls again after restarting
        });

        document.getElementById('startButton').addEventListener('click', () => {
            document.getElementById('splashScreen').style.display = 'none'; // Hide splash screen
            controls.lock(); // Lock the controls immediately
            initBottles(); // Initialize bottles
            animate(); // Start animation loop
        });

        function createShards(x, y, z) {
            const shardGroup = new THREE.Group();
            const shardMaterial = new THREE.MeshToonMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            for (let i = 0; i < 10; i++) {
                const shard = new THREE.Mesh(
                    new THREE.TetrahedronGeometry(0.2),
                    shardMaterial
                );
                shard.position.set(
                    x + Math.random() * 0.5 - 0.25,
                    y + Math.random() * 0.5 - 0.25,
                    z + Math.random() * 0.5 - 0.25
                );
                shard.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.1 + 0.05,
                    (Math.random() - 0.5) * 0.1
                );
                shardGroup.add(shard);
            }
            return shardGroup;
        }

        // Animation loop
        const shards = [];
        function animate() {
            requestAnimationFrame(animate);
            camera.fov = isZoomed ? 20 : 75;
            crosshairs.style.display = isZoomed ? 'block' : 'none';

            clouds.forEach(cloud => {
                cloud.position.x += 0.05;
                if (cloud.position.x > 30) {
                    cloud.position.x = -30;
                }
            });
            shards.forEach(shardGroup => {
                shardGroup.children.forEach(shard => {
                    shard.velocity.y -= 0.001; // Gravity
                    shard.position.add(shard.velocity);
                });
                shardGroup.lifespan -= 1;
                if (shardGroup.lifespan <= 0) {
                    scene.remove(shardGroup);
                    shards.splice(shards.indexOf(shardGroup), 1);
                }
            });
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>